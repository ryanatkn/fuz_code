var xt=e=>{throw TypeError(e)};var nn=(e,t,n)=>t.has(e)||xt("Cannot "+n);var i=(e,t,n)=>(nn(e,t,"read from private field"),n?n.call(e):t.get(e)),c=(e,t,n)=>t.has(e)?xt("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n);import{e as Gt,a as j,d as ct,f as $t}from"./DlUSUuuE.js";import{p as Wt,a as Nt,J as u,s as I,c as E,K as p,r as A,f as dt,t as zt,F as lt,ah as L,W as d}from"./Brg_2F-A.js";import{s as rn}from"./p6G_AVMl.js";import{h as an,s as Ye}from"./7HYJ4EGG.js";import{p as mt,i as tt}from"./Dx_bBUwt.js";import{b as St,S as sn,C as on,e as ln,s as Tt}from"./Bd_5h5Vr.js";import{a as nt,s as O,e as Dt,r as un}from"./DWziG3Xr.js";import"./DM_bz5E8.js";function _(e,t,n){function r(l,m){var h;Object.defineProperty(l,"_zod",{value:l._zod??{},enumerable:!1}),(h=l._zod).traits??(h.traits=new Set),l._zod.traits.add(e),t(l,m);for(const g in o.prototype)g in l||Object.defineProperty(l,g,{value:o.prototype[g].bind(l)});l._zod.constr=o,l._zod.def=m}const a=(n==null?void 0:n.Parent)??Object;class s extends a{}Object.defineProperty(s,"name",{value:e});function o(l){var m;const h=n!=null&&n.Parent?new s:this;r(h,l),(m=h._zod).deferred??(m.deferred=[]);for(const g of h._zod.deferred)g();return h}return Object.defineProperty(o,"init",{value:r}),Object.defineProperty(o,Symbol.hasInstance,{value:l=>{var m,h;return n!=null&&n.Parent&&l instanceof n.Parent?!0:(h=(m=l==null?void 0:l._zod)==null?void 0:m.traits)==null?void 0:h.has(e)}}),Object.defineProperty(o,"name",{value:e}),o}class V extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}class Ut extends Error{constructor(t){super(`Encountered unidirectional transform during encode: ${t}`),this.name="ZodEncodeError"}}const cn={};function Z(e){return cn}function pt(e,t){return typeof t=="bigint"?t.toString():t}function gt(e){return e==null}function ft(e){const t=e.startsWith("^")?1:0,n=e.endsWith("$")?e.length-1:e.length;return e.slice(t,n)}const Ct=Symbol("evaluating");function y(e,t,n){let r;Object.defineProperty(e,t,{get(){if(r!==Ct)return r===void 0&&(r=Ct,r=n()),r},set(a){Object.defineProperty(e,t,{value:a})},configurable:!0})}function dn(...e){const t={};for(const n of e){const r=Object.getOwnPropertyDescriptors(n);Object.assign(t,r)}return Object.defineProperties({},t)}const Bt="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function Ht(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}function _t(e){if(Ht(e)===!1)return!1;const t=e.constructor;if(t===void 0)return!0;const n=t.prototype;return!(Ht(n)===!1||Object.prototype.hasOwnProperty.call(n,"isPrototypeOf")===!1)}function Ft(e){return _t(e)?{...e}:Array.isArray(e)?[...e]:e}function yt(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function mn(e,t,n){const r=new e._zod.constr(t??e._zod.def);return(!t||n!=null&&n.parent)&&(r._zod.parent=e),r}function b(e){const t=e;if(!t)return{};if(typeof t=="string")return{error:()=>t};if((t==null?void 0:t.message)!==void 0){if((t==null?void 0:t.error)!==void 0)throw new Error("Cannot specify both `message` and `error` params");t.error=t.message}return delete t.message,typeof t.error=="string"?{...t,error:()=>t.error}:t}function R(e,t=0){var n;if(e.aborted===!0)return!0;for(let r=t;r<e.issues.length;r++)if(((n=e.issues[r])==null?void 0:n.continue)!==!0)return!0;return!1}function pn(e,t){return t.map(n=>{var r;return(r=n).path??(r.path=[]),n.path.unshift(e),n})}function Qe(e){return typeof e=="string"?e:e==null?void 0:e.message}function P(e,t,n){var a,s,o,l,m,h;const r={...e,path:e.path??[]};if(!e.message){const g=Qe((o=(s=(a=e.inst)==null?void 0:a._zod.def)==null?void 0:s.error)==null?void 0:o.call(s,e))??Qe((l=t==null?void 0:t.error)==null?void 0:l.call(t,e))??Qe((m=n.customError)==null?void 0:m.call(n,e))??Qe((h=n.localeError)==null?void 0:h.call(n,e))??"Invalid input";r.message=g}return delete r.inst,delete r.continue,t!=null&&t.reportInput||delete r.input,r}function kt(e){return Array.isArray(e)?"array":typeof e=="string"?"string":"unknown"}function M(...e){const[t,n,r]=e;return typeof t=="string"?{message:t,code:"custom",input:n,inst:r}:{...t}}const Jt=(e,t)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:t,enumerable:!1}),e.message=JSON.stringify(t,pt,2),Object.defineProperty(e,"toString",{value:()=>e.message,enumerable:!1})},qt=_("$ZodError",Jt),Kt=_("$ZodError",Jt,{Parent:Error});function _n(e,t=n=>n.message){const n={},r=[];for(const a of e.issues)a.path.length>0?(n[a.path[0]]=n[a.path[0]]||[],n[a.path[0]].push(t(a))):r.push(t(a));return{formErrors:r,fieldErrors:n}}function hn(e,t=n=>n.message){const n={_errors:[]},r=a=>{for(const s of a.issues)if(s.code==="invalid_union"&&s.errors.length)s.errors.map(o=>r({issues:o}));else if(s.code==="invalid_key")r({issues:s.issues});else if(s.code==="invalid_element")r({issues:s.issues});else if(s.path.length===0)n._errors.push(t(s));else{let o=n,l=0;for(;l<s.path.length;){const m=s.path[l];l===s.path.length-1?(o[m]=o[m]||{_errors:[]},o[m]._errors.push(t(s))):o[m]=o[m]||{_errors:[]},o=o[m],l++}}};return r(e),n}const vt=e=>(t,n,r,a)=>{const s=r?Object.assign(r,{async:!1}):{async:!1},o=t._zod.run({value:n,issues:[]},s);if(o instanceof Promise)throw new V;if(o.issues.length){const l=new((a==null?void 0:a.Err)??e)(o.issues.map(m=>P(m,s,Z())));throw Bt(l,a==null?void 0:a.callee),l}return o.value},bt=e=>async(t,n,r,a)=>{const s=r?Object.assign(r,{async:!0}):{async:!0};let o=t._zod.run({value:n,issues:[]},s);if(o instanceof Promise&&(o=await o),o.issues.length){const l=new((a==null?void 0:a.Err)??e)(o.issues.map(m=>P(m,s,Z())));throw Bt(l,a==null?void 0:a.callee),l}return o.value},at=e=>(t,n,r)=>{const a=r?{...r,async:!1}:{async:!1},s=t._zod.run({value:n,issues:[]},a);if(s instanceof Promise)throw new V;return s.issues.length?{success:!1,error:new(e??qt)(s.issues.map(o=>P(o,a,Z())))}:{success:!0,data:s.value}},gn=at(Kt),st=e=>async(t,n,r)=>{const a=r?Object.assign(r,{async:!0}):{async:!0};let s=t._zod.run({value:n,issues:[]},a);return s instanceof Promise&&(s=await s),s.issues.length?{success:!1,error:new e(s.issues.map(o=>P(o,a,Z())))}:{success:!0,data:s.value}},fn=st(Kt),yn=e=>(t,n,r)=>{const a=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return vt(e)(t,n,a)},kn=e=>(t,n,r)=>vt(e)(t,n,r),vn=e=>async(t,n,r)=>{const a=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return bt(e)(t,n,a)},bn=e=>async(t,n,r)=>bt(e)(t,n,r),wn=e=>(t,n,r)=>{const a=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return at(e)(t,n,a)},xn=e=>(t,n,r)=>at(e)(t,n,r),zn=e=>async(t,n,r)=>{const a=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return st(e)(t,n,a)},Sn=e=>async(t,n,r)=>st(e)(t,n,r),Tn=/^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/,Cn=e=>{const t=e?`[\\s\\S]{${(e==null?void 0:e.minimum)??0},${(e==null?void 0:e.maximum)??""}}`:"[\\s\\S]*";return new RegExp(`^${t}$`)},Hn=/^[^A-Z]*$/,jn=/^[^a-z]*$/,C=_("$ZodCheck",(e,t)=>{var n;e._zod??(e._zod={}),e._zod.def=t,(n=e._zod).onattach??(n.onattach=[])}),Zn=_("$ZodCheckMaxLength",(e,t)=>{var n;C.init(e,t),(n=e._zod.def).when??(n.when=r=>{const a=r.value;return!gt(a)&&a.length!==void 0}),e._zod.onattach.push(r=>{const a=r._zod.bag.maximum??Number.POSITIVE_INFINITY;t.maximum<a&&(r._zod.bag.maximum=t.maximum)}),e._zod.check=r=>{const a=r.value;if(a.length<=t.maximum)return;const o=kt(a);r.issues.push({origin:o,code:"too_big",maximum:t.maximum,inclusive:!0,input:a,inst:e,continue:!t.abort})}}),Pn=_("$ZodCheckMinLength",(e,t)=>{var n;C.init(e,t),(n=e._zod.def).when??(n.when=r=>{const a=r.value;return!gt(a)&&a.length!==void 0}),e._zod.onattach.push(r=>{const a=r._zod.bag.minimum??Number.NEGATIVE_INFINITY;t.minimum>a&&(r._zod.bag.minimum=t.minimum)}),e._zod.check=r=>{const a=r.value;if(a.length>=t.minimum)return;const o=kt(a);r.issues.push({origin:o,code:"too_small",minimum:t.minimum,inclusive:!0,input:a,inst:e,continue:!t.abort})}}),En=_("$ZodCheckLengthEquals",(e,t)=>{var n;C.init(e,t),(n=e._zod.def).when??(n.when=r=>{const a=r.value;return!gt(a)&&a.length!==void 0}),e._zod.onattach.push(r=>{const a=r._zod.bag;a.minimum=t.length,a.maximum=t.length,a.length=t.length}),e._zod.check=r=>{const a=r.value,s=a.length;if(s===t.length)return;const o=kt(a),l=s>t.length;r.issues.push({origin:o,...l?{code:"too_big",maximum:t.length}:{code:"too_small",minimum:t.length},inclusive:!0,exact:!0,input:r.value,inst:e,continue:!t.abort})}}),it=_("$ZodCheckStringFormat",(e,t)=>{var n,r;C.init(e,t),e._zod.onattach.push(a=>{const s=a._zod.bag;s.format=t.format,t.pattern&&(s.patterns??(s.patterns=new Set),s.patterns.add(t.pattern))}),t.pattern?(n=e._zod).check??(n.check=a=>{t.pattern.lastIndex=0,!t.pattern.test(a.value)&&a.issues.push({origin:"string",code:"invalid_format",format:t.format,input:a.value,...t.pattern?{pattern:t.pattern.toString()}:{},inst:e,continue:!t.abort})}):(r=e._zod).check??(r.check=()=>{})}),An=_("$ZodCheckRegex",(e,t)=>{it.init(e,t),e._zod.check=n=>{t.pattern.lastIndex=0,!t.pattern.test(n.value)&&n.issues.push({origin:"string",code:"invalid_format",format:"regex",input:n.value,pattern:t.pattern.toString(),inst:e,continue:!t.abort})}}),Rn=_("$ZodCheckLowerCase",(e,t)=>{t.pattern??(t.pattern=Hn),it.init(e,t)}),Vn=_("$ZodCheckUpperCase",(e,t)=>{t.pattern??(t.pattern=jn),it.init(e,t)}),Ln=_("$ZodCheckIncludes",(e,t)=>{C.init(e,t);const n=yt(t.includes),r=new RegExp(typeof t.position=="number"?`^.{${t.position}}${n}`:n);t.pattern=r,e._zod.onattach.push(a=>{const s=a._zod.bag;s.patterns??(s.patterns=new Set),s.patterns.add(r)}),e._zod.check=a=>{a.value.includes(t.includes,t.position)||a.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:t.includes,input:a.value,inst:e,continue:!t.abort})}}),In=_("$ZodCheckStartsWith",(e,t)=>{C.init(e,t);const n=new RegExp(`^${yt(t.prefix)}.*`);t.pattern??(t.pattern=n),e._zod.onattach.push(r=>{const a=r._zod.bag;a.patterns??(a.patterns=new Set),a.patterns.add(n)}),e._zod.check=r=>{r.value.startsWith(t.prefix)||r.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:t.prefix,input:r.value,inst:e,continue:!t.abort})}}),On=_("$ZodCheckEndsWith",(e,t)=>{C.init(e,t);const n=new RegExp(`.*${yt(t.suffix)}$`);t.pattern??(t.pattern=n),e._zod.onattach.push(r=>{const a=r._zod.bag;a.patterns??(a.patterns=new Set),a.patterns.add(n)}),e._zod.check=r=>{r.value.endsWith(t.suffix)||r.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:t.suffix,input:r.value,inst:e,continue:!t.abort})}}),Mn=_("$ZodCheckOverwrite",(e,t)=>{C.init(e,t),e._zod.check=n=>{n.value=t.tx(n.value)}}),Gn={major:4,minor:1,patch:12},w=_("$ZodType",(e,t)=>{var a;var n;e??(e={}),e._zod.def=t,e._zod.bag=e._zod.bag||{},e._zod.version=Gn;const r=[...e._zod.def.checks??[]];e._zod.traits.has("$ZodCheck")&&r.unshift(e);for(const s of r)for(const o of s._zod.onattach)o(e);if(r.length===0)(n=e._zod).deferred??(n.deferred=[]),(a=e._zod.deferred)==null||a.push(()=>{e._zod.run=e._zod.parse});else{const s=(l,m,h)=>{let g=R(l),z;for(const H of m){if(H._zod.def.when){if(!H._zod.def.when(l))continue}else if(g)continue;const k=l.issues.length,f=H._zod.check(l);if(f instanceof Promise&&(h==null?void 0:h.async)===!1)throw new V;if(z||f instanceof Promise)z=(z??Promise.resolve()).then(async()=>{await f,l.issues.length!==k&&(g||(g=R(l,k)))});else{if(l.issues.length===k)continue;g||(g=R(l,k))}}return z?z.then(()=>l):l},o=(l,m,h)=>{if(R(l))return l.aborted=!0,l;const g=s(m,r,h);if(g instanceof Promise){if(h.async===!1)throw new V;return g.then(z=>e._zod.parse(z,h))}return e._zod.parse(g,h)};e._zod.run=(l,m)=>{if(m.skipChecks)return e._zod.parse(l,m);if(m.direction==="backward"){const g=e._zod.parse({value:l.value,issues:[]},{...m,skipChecks:!0});return g instanceof Promise?g.then(z=>o(z,l,m)):o(g,l,m)}const h=e._zod.parse(l,m);if(h instanceof Promise){if(m.async===!1)throw new V;return h.then(g=>s(g,r,m))}return s(h,r,m)}}e["~standard"]={validate:s=>{var o;try{const l=gn(e,s);return l.success?{value:l.data}:{issues:(o=l.error)==null?void 0:o.issues}}catch{return fn(e,s).then(m=>{var h;return m.success?{value:m.data}:{issues:(h=m.error)==null?void 0:h.issues}})}},vendor:"zod",version:1}}),Yt=_("$ZodString",(e,t)=>{var n;w.init(e,t),e._zod.pattern=[...((n=e==null?void 0:e._zod.bag)==null?void 0:n.patterns)??[]].pop()??Cn(e._zod.bag),e._zod.parse=(r,a)=>{if(t.coerce)try{r.value=String(r.value)}catch{}return typeof r.value=="string"||r.issues.push({expected:"string",code:"invalid_type",input:r.value,inst:e}),r}}),Qt=_("$ZodStringFormat",(e,t)=>{it.init(e,t),Yt.init(e,t)}),$n=_("$ZodURL",(e,t)=>{Qt.init(e,t),e._zod.check=n=>{try{const r=n.value.trim(),a=new URL(r);t.hostname&&(t.hostname.lastIndex=0,t.hostname.test(a.hostname)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:Tn.source,input:n.value,inst:e,continue:!t.abort})),t.protocol&&(t.protocol.lastIndex=0,t.protocol.test(a.protocol.endsWith(":")?a.protocol.slice(0,-1):a.protocol)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:t.protocol.source,input:n.value,inst:e,continue:!t.abort})),t.normalize?n.value=a.href:n.value=r;return}catch{n.issues.push({code:"invalid_format",format:"url",input:n.value,inst:e,continue:!t.abort})}}});function jt(e,t,n){e.issues.length&&t.issues.push(...pn(n,e.issues)),t.value[n]=e.value}const Wn=_("$ZodArray",(e,t)=>{w.init(e,t),e._zod.parse=(n,r)=>{const a=n.value;if(!Array.isArray(a))return n.issues.push({expected:"array",code:"invalid_type",input:a,inst:e}),n;n.value=Array(a.length);const s=[];for(let o=0;o<a.length;o++){const l=a[o],m=t.element._zod.run({value:l,issues:[]},r);m instanceof Promise?s.push(m.then(h=>jt(h,n,o))):jt(m,n,o)}return s.length?Promise.all(s).then(()=>n):n}});function Zt(e,t,n,r){for(const s of e)if(s.issues.length===0)return t.value=s.value,t;const a=e.filter(s=>!R(s));return a.length===1?(t.value=a[0].value,a[0]):(t.issues.push({code:"invalid_union",input:t.value,inst:n,errors:e.map(s=>s.issues.map(o=>P(o,r,Z())))}),t)}const Nn=_("$ZodUnion",(e,t)=>{w.init(e,t),y(e._zod,"optin",()=>t.options.some(a=>a._zod.optin==="optional")?"optional":void 0),y(e._zod,"optout",()=>t.options.some(a=>a._zod.optout==="optional")?"optional":void 0),y(e._zod,"values",()=>{if(t.options.every(a=>a._zod.values))return new Set(t.options.flatMap(a=>Array.from(a._zod.values)))}),y(e._zod,"pattern",()=>{if(t.options.every(a=>a._zod.pattern)){const a=t.options.map(s=>s._zod.pattern);return new RegExp(`^(${a.map(s=>ft(s.source)).join("|")})$`)}});const n=t.options.length===1,r=t.options[0]._zod.run;e._zod.parse=(a,s)=>{if(n)return r(a,s);let o=!1;const l=[];for(const m of t.options){const h=m._zod.run({value:a.value,issues:[]},s);if(h instanceof Promise)l.push(h),o=!0;else{if(h.issues.length===0)return h;l.push(h)}}return o?Promise.all(l).then(m=>Zt(m,a,e,s)):Zt(l,a,e,s)}}),Dn=_("$ZodIntersection",(e,t)=>{w.init(e,t),e._zod.parse=(n,r)=>{const a=n.value,s=t.left._zod.run({value:a,issues:[]},r),o=t.right._zod.run({value:a,issues:[]},r);return s instanceof Promise||o instanceof Promise?Promise.all([s,o]).then(([m,h])=>Pt(n,m,h)):Pt(n,s,o)}});function ht(e,t){if(e===t)return{valid:!0,data:e};if(e instanceof Date&&t instanceof Date&&+e==+t)return{valid:!0,data:e};if(_t(e)&&_t(t)){const n=Object.keys(t),r=Object.keys(e).filter(s=>n.indexOf(s)!==-1),a={...e,...t};for(const s of r){const o=ht(e[s],t[s]);if(!o.valid)return{valid:!1,mergeErrorPath:[s,...o.mergeErrorPath]};a[s]=o.data}return{valid:!0,data:a}}if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return{valid:!1,mergeErrorPath:[]};const n=[];for(let r=0;r<e.length;r++){const a=e[r],s=t[r],o=ht(a,s);if(!o.valid)return{valid:!1,mergeErrorPath:[r,...o.mergeErrorPath]};n.push(o.data)}return{valid:!0,data:n}}return{valid:!1,mergeErrorPath:[]}}function Pt(e,t,n){if(t.issues.length&&e.issues.push(...t.issues),n.issues.length&&e.issues.push(...n.issues),R(e))return e;const r=ht(t.value,n.value);if(!r.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);return e.value=r.data,e}const Un=_("$ZodTransform",(e,t)=>{w.init(e,t),e._zod.parse=(n,r)=>{if(r.direction==="backward")throw new Ut(e.constructor.name);const a=t.transform(n.value,n);if(r.async)return(a instanceof Promise?a:Promise.resolve(a)).then(o=>(n.value=o,n));if(a instanceof Promise)throw new V;return n.value=a,n}});function Et(e,t){return e.issues.length&&t===void 0?{issues:[],value:void 0}:e}const Bn=_("$ZodOptional",(e,t)=>{w.init(e,t),e._zod.optin="optional",e._zod.optout="optional",y(e._zod,"values",()=>t.innerType._zod.values?new Set([...t.innerType._zod.values,void 0]):void 0),y(e._zod,"pattern",()=>{const n=t.innerType._zod.pattern;return n?new RegExp(`^(${ft(n.source)})?$`):void 0}),e._zod.parse=(n,r)=>{if(t.innerType._zod.optin==="optional"){const a=t.innerType._zod.run(n,r);return a instanceof Promise?a.then(s=>Et(s,n.value)):Et(a,n.value)}return n.value===void 0?n:t.innerType._zod.run(n,r)}}),Fn=_("$ZodNullable",(e,t)=>{w.init(e,t),y(e._zod,"optin",()=>t.innerType._zod.optin),y(e._zod,"optout",()=>t.innerType._zod.optout),y(e._zod,"pattern",()=>{const n=t.innerType._zod.pattern;return n?new RegExp(`^(${ft(n.source)}|null)$`):void 0}),y(e._zod,"values",()=>t.innerType._zod.values?new Set([...t.innerType._zod.values,null]):void 0),e._zod.parse=(n,r)=>n.value===null?n:t.innerType._zod.run(n,r)}),Jn=_("$ZodDefault",(e,t)=>{w.init(e,t),e._zod.optin="optional",y(e._zod,"values",()=>t.innerType._zod.values),e._zod.parse=(n,r)=>{if(r.direction==="backward")return t.innerType._zod.run(n,r);if(n.value===void 0)return n.value=t.defaultValue,n;const a=t.innerType._zod.run(n,r);return a instanceof Promise?a.then(s=>At(s,t)):At(a,t)}});function At(e,t){return e.value===void 0&&(e.value=t.defaultValue),e}const qn=_("$ZodPrefault",(e,t)=>{w.init(e,t),e._zod.optin="optional",y(e._zod,"values",()=>t.innerType._zod.values),e._zod.parse=(n,r)=>(r.direction==="backward"||n.value===void 0&&(n.value=t.defaultValue),t.innerType._zod.run(n,r))}),Kn=_("$ZodNonOptional",(e,t)=>{w.init(e,t),y(e._zod,"values",()=>{const n=t.innerType._zod.values;return n?new Set([...n].filter(r=>r!==void 0)):void 0}),e._zod.parse=(n,r)=>{const a=t.innerType._zod.run(n,r);return a instanceof Promise?a.then(s=>Rt(s,e)):Rt(a,e)}});function Rt(e,t){return!e.issues.length&&e.value===void 0&&e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:t}),e}const Yn=_("$ZodCatch",(e,t)=>{w.init(e,t),y(e._zod,"optin",()=>t.innerType._zod.optin),y(e._zod,"optout",()=>t.innerType._zod.optout),y(e._zod,"values",()=>t.innerType._zod.values),e._zod.parse=(n,r)=>{if(r.direction==="backward")return t.innerType._zod.run(n,r);const a=t.innerType._zod.run(n,r);return a instanceof Promise?a.then(s=>(n.value=s.value,s.issues.length&&(n.value=t.catchValue({...n,error:{issues:s.issues.map(o=>P(o,r,Z()))},input:n.value}),n.issues=[]),n)):(n.value=a.value,a.issues.length&&(n.value=t.catchValue({...n,error:{issues:a.issues.map(s=>P(s,r,Z()))},input:n.value}),n.issues=[]),n)}}),Qn=_("$ZodPipe",(e,t)=>{w.init(e,t),y(e._zod,"values",()=>t.in._zod.values),y(e._zod,"optin",()=>t.in._zod.optin),y(e._zod,"optout",()=>t.out._zod.optout),y(e._zod,"propValues",()=>t.in._zod.propValues),e._zod.parse=(n,r)=>{if(r.direction==="backward"){const s=t.out._zod.run(n,r);return s instanceof Promise?s.then(o=>Xe(o,t.in,r)):Xe(s,t.in,r)}const a=t.in._zod.run(n,r);return a instanceof Promise?a.then(s=>Xe(s,t.out,r)):Xe(a,t.out,r)}});function Xe(e,t,n){return e.issues.length?(e.aborted=!0,e):t._zod.run({value:e.value,issues:e.issues},n)}const Xn=_("$ZodReadonly",(e,t)=>{w.init(e,t),y(e._zod,"propValues",()=>t.innerType._zod.propValues),y(e._zod,"values",()=>t.innerType._zod.values),y(e._zod,"optin",()=>t.innerType._zod.optin),y(e._zod,"optout",()=>t.innerType._zod.optout),e._zod.parse=(n,r)=>{if(r.direction==="backward")return t.innerType._zod.run(n,r);const a=t.innerType._zod.run(n,r);return a instanceof Promise?a.then(Vt):Vt(a)}});function Vt(e){return e.value=Object.freeze(e.value),e}const er=_("$ZodCustom",(e,t)=>{C.init(e,t),w.init(e,t),e._zod.parse=(n,r)=>n,e._zod.check=n=>{const r=n.value,a=t.fn(r);if(a instanceof Promise)return a.then(s=>Lt(s,n,r,e));Lt(a,n,r,e)}});function Lt(e,t,n,r){if(!e){const a={code:"custom",input:n,inst:r,path:[...r._zod.def.path??[]],continue:!r._zod.def.abort};r._zod.def.params&&(a.params=r._zod.def.params),t.issues.push(M(a))}}class tr{constructor(){this._map=new WeakMap,this._idmap=new Map}add(t,...n){const r=n[0];if(this._map.set(t,r),r&&typeof r=="object"&&"id"in r){if(this._idmap.has(r.id))throw new Error(`ID ${r.id} already exists in the registry`);this._idmap.set(r.id,t)}return this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(t){const n=this._map.get(t);return n&&typeof n=="object"&&"id"in n&&this._idmap.delete(n.id),this._map.delete(t),this}get(t){const n=t._zod.parent;if(n){const r={...this.get(n)??{}};delete r.id;const a={...r,...this._map.get(t)};return Object.keys(a).length?a:void 0}return this._map.get(t)}has(t){return this._map.has(t)}}function nr(){return new tr}const et=nr();function rr(e,t){return new e({type:"string",format:"url",check:"string_format",abort:!1,...b(t)})}function Xt(e,t){return new Zn({check:"max_length",...b(t),maximum:e})}function rt(e,t){return new Pn({check:"min_length",...b(t),minimum:e})}function en(e,t){return new En({check:"length_equals",...b(t),length:e})}function ar(e,t){return new An({check:"string_format",format:"regex",...b(t),pattern:e})}function sr(e){return new Rn({check:"string_format",format:"lowercase",...b(e)})}function ir(e){return new Vn({check:"string_format",format:"uppercase",...b(e)})}function or(e,t){return new Ln({check:"string_format",format:"includes",...b(t),includes:e})}function lr(e,t){return new In({check:"string_format",format:"starts_with",...b(t),prefix:e})}function ur(e,t){return new On({check:"string_format",format:"ends_with",...b(t),suffix:e})}function Je(e){return new Mn({check:"overwrite",tx:e})}function cr(e){return Je(t=>t.normalize(e))}function dr(){return Je(e=>e.trim())}function mr(){return Je(e=>e.toLowerCase())}function pr(){return Je(e=>e.toUpperCase())}function _r(e,t,n){return new e({type:"array",element:t,...b(n)})}function hr(e,t,n){return new e({type:"custom",check:"custom",fn:t,...b(n)})}function gr(e){const t=fr(n=>(n.addIssue=r=>{if(typeof r=="string")n.issues.push(M(r,n.value,t._zod.def));else{const a=r;a.fatal&&(a.continue=!1),a.code??(a.code="custom"),a.input??(a.input=n.value),a.inst??(a.inst=t),a.continue??(a.continue=!t._zod.def.abort),n.issues.push(M(a))}},e(n.value,n)));return t}function fr(e,t){const n=new C({check:"custom",...b(t)});return n._zod.check=e,n}const yr=(e,t)=>{qt.init(e,t),e.name="ZodError",Object.defineProperties(e,{format:{value:n=>hn(e,n)},flatten:{value:n=>_n(e,n)},addIssue:{value:n=>{e.issues.push(n),e.message=JSON.stringify(e.issues,pt,2)}},addIssues:{value:n=>{e.issues.push(...n),e.message=JSON.stringify(e.issues,pt,2)}},isEmpty:{get(){return e.issues.length===0}}})},T=_("ZodError",yr,{Parent:Error}),kr=vt(T),vr=bt(T),br=at(T),wr=st(T),xr=yn(T),zr=kn(T),Sr=vn(T),Tr=bn(T),Cr=wn(T),Hr=xn(T),jr=zn(T),Zr=Sn(T),x=_("ZodType",(e,t)=>(w.init(e,t),e.def=t,e.type=t.type,Object.defineProperty(e,"_def",{value:t}),e.check=(...n)=>e.clone(dn(t,{checks:[...t.checks??[],...n.map(r=>typeof r=="function"?{_zod:{check:r,def:{check:"custom"},onattach:[]}}:r)]})),e.clone=(n,r)=>mn(e,n,r),e.brand=()=>e,e.register=(n,r)=>(n.add(e,r),e),e.parse=(n,r)=>kr(e,n,r,{callee:e.parse}),e.safeParse=(n,r)=>br(e,n,r),e.parseAsync=async(n,r)=>vr(e,n,r,{callee:e.parseAsync}),e.safeParseAsync=async(n,r)=>wr(e,n,r),e.spa=e.safeParseAsync,e.encode=(n,r)=>xr(e,n,r),e.decode=(n,r)=>zr(e,n,r),e.encodeAsync=async(n,r)=>Sr(e,n,r),e.decodeAsync=async(n,r)=>Tr(e,n,r),e.safeEncode=(n,r)=>Cr(e,n,r),e.safeDecode=(n,r)=>Hr(e,n,r),e.safeEncodeAsync=async(n,r)=>jr(e,n,r),e.safeDecodeAsync=async(n,r)=>Zr(e,n,r),e.refine=(n,r)=>e.check(ra(n,r)),e.superRefine=n=>e.check(aa(n)),e.overwrite=n=>e.check(Je(n)),e.optional=()=>It(e),e.nullable=()=>Ot(e),e.nullish=()=>It(Ot(e)),e.nonoptional=n=>Kr(e,n),e.array=()=>Lr(e),e.or=n=>Or([e,n]),e.and=n=>Gr(e,n),e.transform=n=>Mt(e,Wr(n)),e.default=n=>Br(e,n),e.prefault=n=>Jr(e,n),e.catch=n=>Qr(e,n),e.pipe=n=>Mt(e,n),e.readonly=()=>ta(e),e.describe=n=>{const r=e.clone();return et.add(r,{description:n}),r},Object.defineProperty(e,"description",{get(){var n;return(n=et.get(e))==null?void 0:n.description},configurable:!0}),e.meta=(...n)=>{if(n.length===0)return et.get(e);const r=e.clone();return et.add(r,n[0]),r},e.isOptional=()=>e.safeParse(void 0).success,e.isNullable=()=>e.safeParse(null).success,e)),Pr=_("_ZodString",(e,t)=>{Yt.init(e,t),x.init(e,t);const n=e._zod.bag;e.format=n.format??null,e.minLength=n.minimum??null,e.maxLength=n.maximum??null,e.regex=(...r)=>e.check(ar(...r)),e.includes=(...r)=>e.check(or(...r)),e.startsWith=(...r)=>e.check(lr(...r)),e.endsWith=(...r)=>e.check(ur(...r)),e.min=(...r)=>e.check(rt(...r)),e.max=(...r)=>e.check(Xt(...r)),e.length=(...r)=>e.check(en(...r)),e.nonempty=(...r)=>e.check(rt(1,...r)),e.lowercase=r=>e.check(sr(r)),e.uppercase=r=>e.check(ir(r)),e.trim=()=>e.check(dr()),e.normalize=(...r)=>e.check(cr(...r)),e.toLowerCase=()=>e.check(mr()),e.toUpperCase=()=>e.check(pr())}),Er=_("ZodStringFormat",(e,t)=>{Qt.init(e,t),Pr.init(e,t)}),Ar=_("ZodURL",(e,t)=>{$n.init(e,t),Er.init(e,t)});function Rr(e){return rr(Ar,e)}const Vr=_("ZodArray",(e,t)=>{Wn.init(e,t),x.init(e,t),e.element=t.element,e.min=(n,r)=>e.check(rt(n,r)),e.nonempty=n=>e.check(rt(1,n)),e.max=(n,r)=>e.check(Xt(n,r)),e.length=(n,r)=>e.check(en(n,r)),e.unwrap=()=>e.element});function Lr(e,t){return _r(Vr,e,t)}const Ir=_("ZodUnion",(e,t)=>{Nn.init(e,t),x.init(e,t),e.options=t.options});function Or(e,t){return new Ir({type:"union",options:e,...b(t)})}const Mr=_("ZodIntersection",(e,t)=>{Dn.init(e,t),x.init(e,t)});function Gr(e,t){return new Mr({type:"intersection",left:e,right:t})}const $r=_("ZodTransform",(e,t)=>{Un.init(e,t),x.init(e,t),e._zod.parse=(n,r)=>{if(r.direction==="backward")throw new Ut(e.constructor.name);n.addIssue=s=>{if(typeof s=="string")n.issues.push(M(s,n.value,t));else{const o=s;o.fatal&&(o.continue=!1),o.code??(o.code="custom"),o.input??(o.input=n.value),o.inst??(o.inst=e),n.issues.push(M(o))}};const a=t.transform(n.value,n);return a instanceof Promise?a.then(s=>(n.value=s,n)):(n.value=a,n)}});function Wr(e){return new $r({type:"transform",transform:e})}const Nr=_("ZodOptional",(e,t)=>{Bn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType});function It(e){return new Nr({type:"optional",innerType:e})}const Dr=_("ZodNullable",(e,t)=>{Fn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType});function Ot(e){return new Dr({type:"nullable",innerType:e})}const Ur=_("ZodDefault",(e,t)=>{Jn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType,e.removeDefault=e.unwrap});function Br(e,t){return new Ur({type:"default",innerType:e,get defaultValue(){return typeof t=="function"?t():Ft(t)}})}const Fr=_("ZodPrefault",(e,t)=>{qn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType});function Jr(e,t){return new Fr({type:"prefault",innerType:e,get defaultValue(){return typeof t=="function"?t():Ft(t)}})}const qr=_("ZodNonOptional",(e,t)=>{Kn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType});function Kr(e,t){return new qr({type:"nonoptional",innerType:e,...b(t)})}const Yr=_("ZodCatch",(e,t)=>{Yn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType,e.removeCatch=e.unwrap});function Qr(e,t){return new Yr({type:"catch",innerType:e,catchValue:typeof t=="function"?t:()=>t})}const Xr=_("ZodPipe",(e,t)=>{Qn.init(e,t),x.init(e,t),e.in=t.in,e.out=t.out});function Mt(e,t){return new Xr({type:"pipe",in:e,out:t})}const ea=_("ZodReadonly",(e,t)=>{Xn.init(e,t),x.init(e,t),e.unwrap=()=>e._zod.def.innerType});function ta(e){return new ea({type:"readonly",innerType:e})}const na=_("ZodCustom",(e,t)=>{er.init(e,t),x.init(e,t)});function ra(e,t={}){return hr(na,e,t)}function aa(e){return gr(e)}const sa=e=>nt(O(O(e,"https://"),"www."),"/");Rr();var ia=Gt("<path></path>"),oa=Gt("<svg><!><!></svg>");function la(e,t){Wt(t,!0);const n=mt(t,"size",3,"var(--font_size, auto)"),r=mt(t,"shrink",3,!0),a=p(()=>t.fill??t.data.fill??"var(--text_color, #000)"),s=p(()=>t.width??n()),o=p(()=>t.height??n()),l=p(()=>{var k,f,v,S;return(k=t.data.attrs)!=null&&k.style&&((f=t.attrs)!=null&&f.style)?Dt(t.data.attrs.style,";")+" "+t.attrs.style:((v=t.data.attrs)==null?void 0:v.style)??((S=t.attrs)==null?void 0:S.style)});var m=oa();St(m,(k,f)=>({viewBox:t.data.viewBox??"0 0 100 100",...t.data.attrs,...t.attrs,"aria-label":t.label??t.data.label,style:u(l),[on]:k,[sn]:f}),[()=>({display_inline_block:t.inline,position_relative:t.inline}),()=>({width:u(s),height:u(o),top:t.inline?"0.1em":void 0,"flex-shrink":r()?1:0})]);var h=E(m);{var g=k=>{var f=ct(),v=dt(f);an(v,()=>t.data.raw,!0),j(k,f)};tt(h,k=>{t.data.raw&&k(g)})}var z=I(h);{var H=k=>{var f=ct(),v=dt(f);ln(v,16,()=>t.data.paths,S=>S,(S,ot)=>{var Ke=ia();St(Ke,()=>({fill:u(a),...ot})),j(S,Ke)}),j(k,f)};tt(z,k=>{t.data.paths&&k(H)})}A(m),j(e,m),Nt()}const Oa={label:"a pixelated green oak acorn with a glint of sun",paths:[{fill:"#6f974c",d:"m 24.035592,57.306905 v -14.5 h 16.329497 v 14.25 z"},{fill:"#5e853f",d:"M 43.75,93.75 H 37.5 V 87.5 H 31.25 V 81.25 H 25 V 75 H 18.75 V 62.5 H 12.5 V 50 H 6.25 V 43.75 H 4 v -21 L 22.75,16.5 h 40.5 l 0.5,61.5 -5,-0.75 -0.25,16.5 h -2.25 l -4,2.25 -2.24617,4 H 43.75 Z M 37.5,50 H 31.25 V 43.75 H 25 v 12.5 h 12.5 z"},{fill:"#6f492b",d:"m 50,93.75 h 6.25 V 75 H 62.5 V 50 H 56.25 V 37.5 H 50 V 31.25 H 43.75 V 25 H 31.25 V 18.75 H 25 V 25 H 12.5 v 6.25 H 6.25 v 12.5 H 0 v -25 H 6.25 V 12.5 h 12.5 V 6.25 H 37.5 V 0 h 25 v 6.25 h 18.75 v 6.25 h 12.5 v 6.25 H 100 v 25 H 93.75 V 50 H 87.5 V 62.5 H 81.25 V 75 H 75 v 6.25 H 68.75 V 87.5 H 62.5 v 6.25 H 56.25 V 100 H 50 Z"},{fill:"#3b730f",d:"m 50,93.75 h 6.25 V 75 H 62.5 V 50 H 56.25 V 37.5 H 50 V 31.25 H 43.75 V 25 H 31.25 V 18.75 H 25 V 25 H 12.5 v 6.25 H 6.25 v 12.5 H 0 V 25 H 12.5 V 18.75 H 25 V 12.5 H 43.75 V 6.25 h 12.5 V 12.5 H 75 v 6.25 H 87.5 V 25 H 100 V 43.75 H 93.75 V 50 H 87.5 V 62.5 H 81.25 V 75 H 75 v 6.25 H 68.75 V 87.5 H 62.5 v 6.25 H 56.25 V 100 H 50 Z"},{fill:"#473323",d:"M 87.5,37.5 H 81.25 V 31.25 H 68.75 V 25 H 62.5 V 18.75 H 43.75 25 V 25 H 12.5 v 6.25 H 6.25 v 12.5 H 0 V 25 H 12.5 V 18.75 H 25 V 12.5 H 43.75 V 6.25 h 12.5 V 12.5 H 75 v 6.25 H 87.5 V 25 H 100 V 43.75 H 93.75 V 50 H 87.5 Z"},{fill:"#2e6006",d:"M 87.5,37.5 H 81.25 V 31.25 H 68.75 V 25 H 62.5 v -6.25 h -25 V 12.5 H 50 V 6.25 h 6.25 v 6.25 h 12.5 v 6.25 h 12.5 V 25 h 12.5 v 6.25 H 100 v 12.5 H 93.75 V 50 H 87.5 Z"},{fill:"#34251a",d:"M 93.75,31.25 H 87.5 V 25 h 6.25 v 6.25 H 100 v 12.5 H 93.75 Z M 75,18.75 h 6.25 V 25 H 75 Z M 37.5,12.5 H 50 V 6.25 h 6.25 v 6.25 h 12.5 v 6.25 H 53.125 37.5 Z"}]},qe={label:"a friendly brown spider facing you",fill:"#84522a",paths:[{d:"M 26.253917,88.532336 29.904106,71.394855 40.667193,53.342811 40.258534,49.99234 38.417407,49.000991 22.876908,50.369035 9.4865496,53.880193 2.3019024,57.978424 0.42708056,57.27994 7.2642726,51.086985 20.811326,45.373351 37.960128,42.356792 39.354818,40.107008 38.229925,38.149883 26.030989,27.105568 14.46539,21.861786 8.0479986,18.615387 l -0.41428,-1.710463 8.2789464,1.499862 13.012873,5.003724 13.447448,10.696856 1.680801,-0.729547 0.222439,-1.343157 -3.983998,-12.128053 -5.730215,-9.573597 -0.823624,-5.1744052 1.16944,-1.165102 2.604334,6.3355162 6.612025,7.08777 4.874534,11.55989 2.800804,0.515574 4.48815,-1.359246 1.521623,-8.687062 5.685014,-8.620764 2.75965,-6.8316782 1.094578,1.128569 -1.293029,5.4222362 -4.084776,11.06803 -0.484994,8.377408 0.194311,1.192896 1.42954,1.700726 11.563936,-10.644623 9.878262,-8.331535 8.732915,-3.390708 -0.387305,1.402757 -5.294686,3.023816 -10.445054,10.705792 -9.561599,13.627899 -0.438945,1.602755 1.001398,1.666754 17.376932,3.986302 9.537375,6.940531 4.325785,4.636405 0.211208,1.557106 -6.15842,-4.279925 -10.413771,-5.155697 -15.838715,-1.696223 -0.83461,1.144484 0.774499,2.593247 9.737644,16.194355 3.925704,17.214082 0.07146,10.277289 -1.706242,1.13628 -2.009721,-9.21637 -5.894265,-16.88027 -12.292087,-17.295813 -4.177778,-0.585888 -7.294671,2.935716 -11.138052,16.645915 -6.462422,17.752509 -1.634756,7.206641 -2.070766,-1.52923 z"}]},Ma={label:"a fuzzy tuft of green moss",fill:"#3db33d",paths:qe.paths,attrs:{style:"transform: scaleX(-1) rotate(180deg)"}};qe.paths;qe.paths;qe.paths;qe.paths;const Ga={label:"a friendly orange pixelated spider facing you",fill:"#f4672f",paths:[{d:"m 25,81.200002 h 6.2 v -12.5 h 6.3 v -18.7 h -6.3 v 6.2 H 12.5 v 6.3 H 0 v -6.3 h 6.2 v -6.2 H 25 v -6.3 h 12.5 v -6.2 h -6.3 v -6.3 H 18.7 v -6.2 H 6.2 v -6.3 H 25 v 6.3 h 12.5 v -6.3 H 31.2 V 6.2 h 6.3 v 6.300002 h 6.2 V 31.200001 H 56.2 V 12.500002 h 6.3 V 6.2 h 6.2 v 12.500001 h -6.2 v 18.800001 h 6.2 v -12.5 h 12.5 v -12.5 h 12.5 v 6.2 h -6.2 v 12.5 H 75 v 12.5 h 6.2 v 6.3 h 12.5 v 6.2 h 6.299997 v 6.3 H 87.5 v -6.3 H 75 v -6.2 h -6.3 v 12.5 H 75 v 12.5 h 6.2 V 99.99999 H 75 V 81.200002 h -6.3 v -12.5 h -6.2 v -12.5 H 43.7 v 18.8 h -6.2 v 12.5 H 31.2 V 99.99999 H 25 Z"}]},ua={label:"the GitHub logo, an octocat silhouette",paths:[{d:"M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z","fill-rule":"evenodd","clip-rule":"evenodd",transform:"scale(64)"}],viewBox:"0 0 1024 1024"};var ca=$t('<div class="root_url svelte-cs8o0f"><a> </a></div>'),da=$t('<footer class="box"><!> <div class="logo box panel p_lg shadow_inset_xs svelte-cs8o0f"><!> <a rel="me" title="source code on GitHub" class="svelte-cs8o0f"><!></a> <!></div> <!></footer>');function $a(e,t){Wt(t,!0);const n=mt(t,"root_url",3,null);var r=da(),a=E(r);Ye(a,()=>t.children??lt);var s=I(a,2),o=E(s);Ye(o,()=>t.logo_header??lt);var l=I(o,2),m=E(l);{var h=f=>{var v=ct(),S=dt(v);Ye(S,()=>t.logo),j(f,v)},g=f=>{la(f,{get data(){return ua},size:"var(--icon_size_lg)"})};tt(m,f=>{t.logo?f(h):f(g,!1)})}A(l);var z=I(l,2);Ye(z,()=>t.logo_footer??lt),A(s);var H=I(s,2);{var k=f=>{var v=ca(),S=E(v),ot=E(S,!0);A(S),A(v),zt(Ke=>{Tt(S,"href",n()),rn(ot,Ke)},[()=>sa(n())]),j(f,v)};tt(H,f=>{n()&&f(k)})}A(r),zt(()=>Tt(l,"href",t.pkg.repo_url)),j(e,r),Nt()}const ma=e=>{var t;if((t=e.generic_params)!=null&&t.length){const n=e.generic_params.map(r=>{let a=r.name;return r.constraint&&(a+=` extends ${r.constraint}`),r.default_type&&(a+=` = ${r.default_type}`),a}).join(", ");return`${e.name}<${n}>`}return e.name},pa=(e,t,n)=>{const r=t.replace("./",`${n}/`);return e.name==="default"?`import ${t.replace("./","").replace(/\.(js|ts|svelte)$/,"").split(/[-_]/).map(l=>l.charAt(0).toUpperCase()+l.slice(1)).join("")} from '${r}';`:`${e.kind==="type"?"import type ":"import "}{${e.name}} from '${r}';`},_a="/docs",ha=un("/docs"),tn=ha+"/api",ga=e=>`${tn}#${encodeURIComponent(e)}`,fa=(e,t)=>`${e}${_a}/api#${encodeURIComponent(t)}`,ya=e=>`${tn}/${e}`,wt=(e,t,n)=>{const r=t.replace(/^\.\//,""),a=`${e}/blob/main/${r}`;return n?`${a}#L${n}`:a},ka=(e,t)=>e.endsWith("/"+t)?nt(e,"/"+t):null,va=e=>{const t=O(e,"https://github.com/");return t===e?null:t.split("/")[0]||null},ba=e=>"https://www.npmjs.com/package/"+e,wa=e=>!e.private&&!!e.exports&&e.version!=="0.0.1",xa=(e,t)=>{if(!e)return null;const n=t?O(t,"/"):"favicon.png";return Dt(e,"/")+n},za=e=>{if(e[0]==="@"){const t=e.split("/");if(t.length<2)throw new Error(`invalid scoped package name: "${e}" (expected format: @org/package)`);return t[1]}return e},Sa=e=>{if(!e)return null;const t=typeof e=="string"?e:e.url;return t?nt(O(nt(t,".git"),"git+"),"/"):null};var G,$,W,N,D,U,B,F,J,q,K,Y,Q,X,ee,te,ne,re,ae,se,ie,oe,le,ue,ce,de,me,pe,_e,he,ge,fe,ye;class Ta{constructor(t,n){c(this,G,L());c(this,$,L());c(this,W,p(()=>this.module.pkg));c(this,N,p(()=>this.module.path));c(this,D,p(()=>this.identifier_json.name));c(this,U,p(()=>this.identifier_json.kind));c(this,B,p(()=>this.pkg.repo_url&&this.identifier_json.source_line?wt(this.pkg.repo_url,`src/lib/${this.module_path}`,this.identifier_json.source_line):void 0));c(this,F,p(()=>ga(this.name)));c(this,J,p(()=>pa(this.identifier_json,this.module_path,this.pkg.package_json.name)));c(this,q,p(()=>this.pkg.homepage_url?fa(this.pkg.homepage_url,this.name):void 0));c(this,K,p(()=>ma(this.identifier_json)));c(this,Y,p(()=>this.identifier_json.type_signature));c(this,Q,p(()=>this.identifier_json.doc_comment));c(this,X,p(()=>this.identifier_json.deprecated_message));c(this,ee,p(()=>this.identifier_json.parameters));c(this,te,p(()=>this.identifier_json.props));c(this,ne,p(()=>this.identifier_json.return_type));c(this,re,p(()=>this.identifier_json.return_description));c(this,ae,p(()=>this.identifier_json.generic_params));c(this,se,p(()=>this.identifier_json.extends));c(this,ie,p(()=>this.identifier_json.implements));c(this,oe,p(()=>this.identifier_json.throws));c(this,le,p(()=>this.identifier_json.since));c(this,ue,p(()=>this.identifier_json.examples));c(this,ce,p(()=>this.identifier_json.see_also));c(this,de,p(()=>this.identifier_json.members));c(this,me,p(()=>this.identifier_json.properties));c(this,pe,p(()=>!!(this.examples&&this.examples.length>0)));c(this,_e,p(()=>!!this.deprecated_message));c(this,he,p(()=>!!this.doc_comment));c(this,ge,p(()=>!!(this.parameters&&this.parameters.length>0)));c(this,fe,p(()=>!!(this.props&&this.props.length>0)));c(this,ye,p(()=>!!(this.generic_params&&this.generic_params.length>0)));this.module=t,this.identifier_json=n}get module(){return u(i(this,G))}set module(t){d(i(this,G),t)}get identifier_json(){return u(i(this,$))}set identifier_json(t){d(i(this,$),t)}get pkg(){return u(i(this,W))}set pkg(t){d(i(this,W),t)}get module_path(){return u(i(this,N))}set module_path(t){d(i(this,N),t)}get name(){return u(i(this,D))}set name(t){d(i(this,D),t)}get kind(){return u(i(this,U))}set kind(t){d(i(this,U),t)}get url_github(){return u(i(this,B))}set url_github(t){d(i(this,B),t)}get url_api(){return u(i(this,F))}set url_api(t){d(i(this,F),t)}get import_statement(){return u(i(this,J))}set import_statement(t){d(i(this,J),t)}get url_api_full(){return u(i(this,q))}set url_api_full(t){d(i(this,q),t)}get display_name(){return u(i(this,K))}set display_name(t){d(i(this,K),t)}get type_signature(){return u(i(this,Y))}set type_signature(t){d(i(this,Y),t)}get doc_comment(){return u(i(this,Q))}set doc_comment(t){d(i(this,Q),t)}get deprecated_message(){return u(i(this,X))}set deprecated_message(t){d(i(this,X),t)}get parameters(){return u(i(this,ee))}set parameters(t){d(i(this,ee),t)}get props(){return u(i(this,te))}set props(t){d(i(this,te),t)}get return_type(){return u(i(this,ne))}set return_type(t){d(i(this,ne),t)}get return_description(){return u(i(this,re))}set return_description(t){d(i(this,re),t)}get generic_params(){return u(i(this,ae))}set generic_params(t){d(i(this,ae),t)}get extends(){return u(i(this,se))}set extends(t){d(i(this,se),t)}get implements(){return u(i(this,ie))}set implements(t){d(i(this,ie),t)}get throws(){return u(i(this,oe))}set throws(t){d(i(this,oe),t)}get since(){return u(i(this,le))}set since(t){d(i(this,le),t)}get examples(){return u(i(this,ue))}set examples(t){d(i(this,ue),t)}get see_also(){return u(i(this,ce))}set see_also(t){d(i(this,ce),t)}get members(){return u(i(this,de))}set members(t){d(i(this,de),t)}get properties(){return u(i(this,me))}set properties(t){d(i(this,me),t)}get has_examples(){return u(i(this,pe))}set has_examples(t){d(i(this,pe),t)}get is_deprecated(){return u(i(this,_e))}set is_deprecated(t){d(i(this,_e),t)}get has_documentation(){return u(i(this,he))}set has_documentation(t){d(i(this,he),t)}get has_parameters(){return u(i(this,ge))}set has_parameters(t){d(i(this,ge),t)}get has_props(){return u(i(this,fe))}set has_props(t){d(i(this,fe),t)}get has_generics(){return u(i(this,ye))}set has_generics(t){d(i(this,ye),t)}}G=new WeakMap,$=new WeakMap,W=new WeakMap,N=new WeakMap,D=new WeakMap,U=new WeakMap,B=new WeakMap,F=new WeakMap,J=new WeakMap,q=new WeakMap,K=new WeakMap,Y=new WeakMap,Q=new WeakMap,X=new WeakMap,ee=new WeakMap,te=new WeakMap,ne=new WeakMap,re=new WeakMap,ae=new WeakMap,se=new WeakMap,ie=new WeakMap,oe=new WeakMap,le=new WeakMap,ue=new WeakMap,ce=new WeakMap,de=new WeakMap,me=new WeakMap,pe=new WeakMap,_e=new WeakMap,he=new WeakMap,ge=new WeakMap,fe=new WeakMap,ye=new WeakMap;var ke,ve,be,we,xe,ze,Se,Te,Ce,He,je,Ze;class Ca{constructor(t,n){c(this,ke,L());c(this,ve,L());c(this,be,p(()=>this.module_json.path));c(this,we,p(()=>"./"+this.path));c(this,xe,p(()=>this.module_json.module_comment));c(this,ze,p(()=>this.module_json.identifiers?this.module_json.identifiers.filter(t=>t.name!=="default").map(t=>new Ta(this,t)):[]));c(this,Se,p(()=>ya(this.path)));c(this,Te,p(()=>this.pkg.repo_url?wt(this.pkg.repo_url,`src/lib/${this.path}`):void 0));c(this,Ce,p(()=>!!(this.module_json.identifiers&&this.module_json.identifiers.length>0)));c(this,He,p(()=>!!this.module_json.module_comment));c(this,je,p(()=>this.module_json.dependencies));c(this,Ze,p(()=>this.module_json.dependents));this.pkg=t,this.module_json=n}get pkg(){return u(i(this,ke))}set pkg(t){d(i(this,ke),t)}get module_json(){return u(i(this,ve))}set module_json(t){d(i(this,ve),t)}get path(){return u(i(this,be))}set path(t){d(i(this,be),t)}get path_import(){return u(i(this,we))}set path_import(t){d(i(this,we),t)}get module_comment(){return u(i(this,xe))}set module_comment(t){d(i(this,xe),t)}get identifiers(){return u(i(this,ze))}set identifiers(t){d(i(this,ze),t)}get url_api(){return u(i(this,Se))}set url_api(t){d(i(this,Se),t)}get url_github(){return u(i(this,Te))}set url_github(t){d(i(this,Te),t)}get has_identifiers(){return u(i(this,Ce))}set has_identifiers(t){d(i(this,Ce),t)}get has_module_comment(){return u(i(this,He))}set has_module_comment(t){d(i(this,He),t)}get dependencies(){return u(i(this,je))}set dependencies(t){d(i(this,je),t)}get dependents(){return u(i(this,Ze))}set dependents(t){d(i(this,Ze),t)}get_identifier_by_name(t){return this.identifiers.find(n=>n.name===t)}}ke=new WeakMap,ve=new WeakMap,be=new WeakMap,we=new WeakMap,xe=new WeakMap,ze=new WeakMap,Se=new WeakMap,Te=new WeakMap,Ce=new WeakMap,He=new WeakMap,je=new WeakMap,Ze=new WeakMap;var Pe,Ee,Ae,Re,Ve,Le,Ie,Oe,Me,Ge,$e,We,Ne,De,Ue,Be,Fe;class Wa{constructor(t,n){c(this,Pe,L());c(this,Ee,L());c(this,Ae,p(()=>this.package_json.name));c(this,Re,p(()=>za(this.package_json.name)));c(this,Ve,p(()=>(()=>{const t=Sa(this.package_json.repository);if(!t)throw Error("failed to parse pkg - `repo_url` is required in package_json");return t})()));c(this,Le,p(()=>this.repo_url?va(this.repo_url):null));c(this,Ie,p(()=>this.package_json.homepage??null));c(this,Oe,p(()=>xa(this.homepage_url,this.package_json.logo)));c(this,Me,p(()=>this.package_json.logo_alt??`logo for ${this.repo_name}`));c(this,Ge,p(()=>wa(this.package_json)));c(this,$e,p(()=>this.published?ba(this.package_json.name):null));c(this,We,p(()=>this.published&&this.repo_url?wt(this.repo_url,"CHANGELOG.md"):null));c(this,Ne,p(()=>ka(this.repo_url,this.repo_name)));c(this,De,p(()=>this.src_json.modules?this.src_json.modules.map(t=>new Ca(this,t)):[]));c(this,Ue,p(()=>[...this.modules].sort((t,n)=>t.path.localeCompare(n.path))));c(this,Be,p(()=>this.modules.flatMap(t=>t.identifiers)));c(this,Fe,p(()=>new Map(this.identifiers.map(t=>[t.name,t]))));this.package_json=t,this.src_json=n}get package_json(){return u(i(this,Pe))}set package_json(t){d(i(this,Pe),t)}get src_json(){return u(i(this,Ee))}set src_json(t){d(i(this,Ee),t)}get name(){return u(i(this,Ae))}set name(t){d(i(this,Ae),t)}get repo_name(){return u(i(this,Re))}set repo_name(t){d(i(this,Re),t)}get repo_url(){return u(i(this,Ve))}set repo_url(t){d(i(this,Ve),t)}get owner_name(){return u(i(this,Le))}set owner_name(t){d(i(this,Le),t)}get homepage_url(){return u(i(this,Ie))}set homepage_url(t){d(i(this,Ie),t)}get logo_url(){return u(i(this,Oe))}set logo_url(t){d(i(this,Oe),t)}get logo_alt(){return u(i(this,Me))}set logo_alt(t){d(i(this,Me),t)}get published(){return u(i(this,Ge))}set published(t){d(i(this,Ge),t)}get npm_url(){return u(i(this,$e))}set npm_url(t){d(i(this,$e),t)}get changelog_url(){return u(i(this,We))}set changelog_url(t){d(i(this,We),t)}get org_url(){return u(i(this,Ne))}set org_url(t){d(i(this,Ne),t)}get modules(){return u(i(this,De))}set modules(t){d(i(this,De),t)}get modules_sorted(){return u(i(this,Ue))}set modules_sorted(t){d(i(this,Ue),t)}get identifiers(){return u(i(this,Be))}set identifiers(t){d(i(this,Be),t)}get identifier_map(){return u(i(this,Fe))}set identifier_map(t){d(i(this,Fe),t)}lookup_identifier(t){return this.identifier_map.get(t)}has_identifier(t){return this.identifier_map.has(t)}lookup_module(t){return this.modules.find(n=>n.path===t)}search_identifiers(t){return Ha(this.identifiers,t)}}Pe=new WeakMap,Ee=new WeakMap,Ae=new WeakMap,Re=new WeakMap,Ve=new WeakMap,Le=new WeakMap,Ie=new WeakMap,Oe=new WeakMap,Me=new WeakMap,Ge=new WeakMap,$e=new WeakMap,We=new WeakMap,Ne=new WeakMap,De=new WeakMap,Ue=new WeakMap,Be=new WeakMap,Fe=new WeakMap;const Ha=(e,t)=>{if(!t.trim())return[];const n=t.trim().toLowerCase().split(/\s+/);return e.map(a=>{let s=0;for(const o of n){const l=ut(a.name,o),m=ut(a.kind,o),h=ut(a.module_path,o),g=Math.max(l,m,h);if(g===0)return null;s+=g}return{identifier:a,score:s}}).filter(a=>a!==null).sort((a,s)=>s.score-a.score||a.identifier.name.localeCompare(s.identifier.name)).map(a=>a.identifier)},ut=(e,t)=>{const n=e.toLowerCase();if(n===t)return 100;if(n.startsWith(t))return 80;if(n.includes(t))return 60;let r=0;for(const a of n)if(a===t[r]&&(r++,r===t.length))return 40;return 0},Na={name:"@ryanatkn/fuz_code",version:"0.33.0",description:"syntax styling utilities and components for TypeScript, Svelte, and Markdown",glyph:"ðŸŽ¨",logo:"logo.svg",logo_alt:"a friendly pink spider facing you",public:!0,license:"MIT",homepage:"https://code.fuz.dev/",repository:"https://github.com/ryanatkn/fuz_code",author:{name:"Ryan Atkinson",email:"mail@ryanatkn.com",url:"https://www.ryanatkn.com/"},bugs:"https://github.com/ryanatkn/fuz_code/issues",funding:"https://www.ryanatkn.com/funding",scripts:{start:"gro dev",dev:"gro dev",build:"gro build",check:"gro check",test:"gro test",preview:"vite preview",deploy:"gro deploy",benchmark:"gro run benchmark/run_benchmarks.ts","benchmark-compare":"gro run benchmark/compare/run_compare.ts","update-generated-fixtures":"gro src/test/fixtures/update"},type:"module",engines:{node:">=22.15"},peerDependencies:{"@ryanatkn/moss":"^0.37.0",svelte:"^5"},peerDependenciesMeta:{"@ryanatkn/moss":{optional:!0},svelte:{optional:!0}},devDependencies:{"@changesets/changelog-git":"^0.2.1","@ryanatkn/belt":"^0.38.0","@ryanatkn/eslint-config":"^0.9.0","@ryanatkn/fuz":"^0.156.0","@ryanatkn/gro":"^0.174.1","@ryanatkn/moss":"^0.37.0","@sveltejs/adapter-static":"^3.0.9","@sveltejs/kit":"^2.37.1","@sveltejs/package":"^2.5.0","@sveltejs/vite-plugin-svelte":"^6.1.4","@types/node":"^24.3.1",eslint:"^9.35.0","eslint-plugin-svelte":"^3.12.1","esm-env":"^1.2.2",prettier:"^3.6.2","prettier-plugin-svelte":"^3.4.0",svelte:"^5.38.7","svelte-check":"^4.3.1",tinybench:"^5.0.1",tslib:"^2.8.1",typescript:"^5.9.2","typescript-eslint":"^8.42.0",vitest:"^3.2.4"},prettier:{plugins:["prettier-plugin-svelte"],useTabs:!0,printWidth:100,singleQuote:!0,bracketSpacing:!1,overrides:[{files:"package.json",options:{useTabs:!1}}]},sideEffects:["**/*.css"],files:["dist","src/lib/**/*.ts","!src/lib/**/*.test.*","!dist/**/*.test.*"],exports:{"./package.json":"./package.json","./*.js":{types:"./dist/*.d.ts",default:"./dist/*.js"},"./*.ts":{types:"./dist/*.d.ts",default:"./dist/*.js"},"./*.svelte":{types:"./dist/*.svelte.d.ts",svelte:"./dist/*.svelte",default:"./dist/*.svelte"},"./*.json":{types:"./dist/*.json.d.ts",default:"./dist/*.json"},"./*.css":{default:"./dist/*.css"}}},Da={name:"@ryanatkn/fuz_code",version:"0.33.0",modules:[{path:"Code_Highlight.svelte",identifiers:[{name:"Code_Highlight",kind:"component",props:[{name:"content",type:"string",optional:!1,description:"The source code to syntax highlight."},{name:"lang",type:"string | null",optional:!0,description:"Language identifier (e.g., 'ts', 'css', 'html', 'json', 'svelte', 'md').\n\n**Purpose:**\n- When `grammar` is not provided, used to look up the grammar via `syntax_styler.get_lang(lang)`\n- Used for metadata: sets the `data-lang` attribute and determines `language_supported`\n\n**Special values:**\n- `null` - Explicitly disables syntax highlighting (content rendered as plain text)\n- `undefined` - Falls back to default ('svelte')\n\n**Relationship with `grammar`:**\n- If both `lang` and `grammar` are provided, `grammar` takes precedence for tokenization\n- However, `lang` is still used for the `data-lang` attribute and language detection"},{name:"mode",type:"Highlight_Mode",optional:!0,description:"Highlighting mode for this component.\n\n**Options:**\n- `'auto'` - Uses CSS Custom Highlight API if supported, falls back to HTML mode\n- `'ranges'` - Forces CSS Custom Highlight API (requires browser support)\n- `'html'` - Forces HTML generation with CSS classes\n\n**Note:** CSS Custom Highlight API has limitations and limited browser support.\nRequires importing `theme_highlight.css` instead of `theme.css`."},{name:"grammar",type:"Syntax_Grammar | undefined",optional:!0,description:`Optional custom grammar object for syntax tokenization.

**When to use:**
- To provide a custom language definition not registered in \`syntax_styler.langs\`
- To use a modified/extended version of an existing grammar
- For one-off grammar variations without registering globally

**Behavior:**
- When provided, this grammar is used for tokenization instead of looking up via \`lang\`
- Enables highlighting even if \`lang\` is not in the registry (useful for custom languages)
- The \`lang\` parameter is still used for metadata (data-lang attribute)
- When undefined, the grammar is automatically looked up via \`syntax_styler.get_lang(lang)\``},{name:"inline",type:"boolean",optional:!0,description:`Whether to render as inline code or block code.
Controls display via CSS classes.`},{name:"wrap",type:"boolean",optional:!0,description:`Whether to wrap long lines in block code.
Sets \`white-space: pre-wrap\` instead of \`white-space: pre\`.

**Behavior:**
- Wraps at whitespace (spaces, newlines)
- Long tokens without spaces (URLs, hashes) will still scroll horizontally
- Default \`false\` provides traditional code block behavior

Only affects block code (ignored for inline mode).`},{name:"syntax_styler",type:"Syntax_Styler",optional:!0,description:`Custom Syntax_Styler instance to use for highlighting.
Allows using a different styler with custom grammars or configuration.`},{name:"children",type:"Snippet<[markup: string]>",optional:!0,description:`Optional snippet to customize how the highlighted markup is rendered.
- In HTML mode: receives the generated HTML string
- In range mode: receives the plain text content`}],source_line:1}],dependencies:["highlight_manager.ts","syntax_styler_global.ts","tokenize_syntax.ts"]},{path:"code_sample.ts",identifiers:[{name:"Code_Sample",kind:"type",source_line:1,type_signature:"Code_Sample",properties:[{name:"name",kind:"variable",type_signature:"string"},{name:"lang",kind:"variable",type_signature:"string"},{name:"content",kind:"variable",type_signature:"string"}]},{name:"sample_langs",kind:"variable",source_line:8,type_signature:'readonly ["json", "css", "ts", "html", "svelte", "md"]'},{name:"Sample_Lang",kind:"type",source_line:10,type_signature:'"json" | "css" | "ts" | "html" | "svelte" | "md"'}],dependents:["samples/all.gen.ts","samples/all.ts","samples/sample_complex.ts"]},{path:"Code.svelte",identifiers:[{name:"Code",kind:"component",props:[{name:"content",type:"string",optional:!1,description:"The source code to syntax highlight."},{name:"lang",type:"string | null",optional:!0,description:"Language identifier (e.g., 'ts', 'css', 'html', 'json', 'svelte', 'md').\n\n**Purpose:**\n- When `grammar` is not provided, used to look up the grammar via `syntax_styler.get_lang(lang)`\n- Used for metadata: sets the `data-lang` attribute and determines `language_supported`\n\n**Special values:**\n- `null` - Explicitly disables syntax highlighting (content rendered as plain text)\n- `undefined` - Falls back to default ('svelte')\n\n**Relationship with `grammar`:**\n- If both `lang` and `grammar` are provided, `grammar` takes precedence for tokenization\n- However, `lang` is still used for the `data-lang` attribute and language detection"},{name:"grammar",type:"Syntax_Grammar | undefined",optional:!0,description:`Optional custom grammar object for syntax tokenization.

**When to use:**
- To provide a custom language definition not registered in \`syntax_styler.langs\`
- To use a modified/extended version of an existing grammar
- For one-off grammar variations without registering globally

**Behavior:**
- When provided, this grammar is used for tokenization instead of looking up via \`lang\`
- Enables highlighting even if \`lang\` is not in the registry (useful for custom languages)
- The \`lang\` parameter is still used for metadata (data-lang attribute)
- When undefined, the grammar is automatically looked up via \`syntax_styler.get_lang(lang)\``},{name:"inline",type:"boolean",optional:!0,description:`Whether to render as inline code or block code.
Controls display via CSS classes.`},{name:"wrap",type:"boolean",optional:!0,description:`Whether to wrap long lines in block code.
Sets \`white-space: pre-wrap\` instead of \`white-space: pre\`.

**Behavior:**
- Wraps at whitespace (spaces, newlines)
- Long tokens without spaces (URLs, hashes) will still scroll horizontally
- Default \`false\` provides traditional code block behavior

Only affects block code (ignored for inline mode).`},{name:"syntax_styler",type:"Syntax_Styler",optional:!0,description:`Custom Syntax_Styler instance to use for highlighting.
Allows using a different styler with custom grammars or configuration.`},{name:"children",type:"Snippet<[markup: string]>",optional:!0,description:`Optional snippet to customize how the highlighted markup is rendered.
Receives the generated HTML string as a parameter.`}],source_line:1}],dependencies:["syntax_styler_global.ts"]},{path:"grammar_clike.ts",identifiers:[{name:"class_keywords",kind:"variable",source_line:3,type_signature:'"class|extends|implements|instanceof|interface|new"'},{name:"add_grammar_clike",kind:"function",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:13,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]}],dependents:["grammar_js.ts","grammar_ts.ts","syntax_styler_global.ts"]},{path:"grammar_css.ts",identifiers:[{name:"add_grammar_css",kind:"function",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:14,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]}],dependencies:["grammar_markup.ts"],dependents:["syntax_styler_global.ts"]},{path:"grammar_js.ts",identifiers:[{name:"add_grammar_js",kind:"function",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:13,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]}],dependencies:["grammar_clike.ts","grammar_markup.ts"],dependents:["syntax_styler_global.ts"]},{path:"grammar_json.ts",identifiers:[{name:"add_grammar_json",kind:"function",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:11,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]}],dependents:["syntax_styler_global.ts"]},{path:"grammar_markdown.ts",identifiers:[{name:"add_grammar_markdown",kind:"function",doc_comment:`Markdown grammar extending markup.
Supports: headings, fenced code blocks (3/4/5 backticks with nesting), lists, blockquotes,
bold, italic, strikethrough, inline code, and links.`,source_line:97,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]}],dependents:["syntax_styler_global.ts"]},{path:"grammar_markup.ts",identifiers:[{name:"add_grammar_markup",kind:"function",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:17,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]},{name:"grammar_markup_add_inlined",kind:"function",doc_comment:"Adds an inlined language to markup.\n\nAn example of an inlined language is CSS with `<style>` tags.",source_line:105,type_signature:"(syntax_styler: Syntax_Styler, tag_name: string, lang: string, inside_lang?: string): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1},{name:"tag_name",type:"string",optional:!1,description:`- The name of the tag that contains the inlined language. This name will be treated as
case insensitive.`},{name:"lang",type:"string",optional:!1,description:"- The language key."},{name:"inside_lang",type:"string",optional:!1,default_value:"'markup'"}]},{name:"grammar_markup_add_attribute",kind:"function",doc_comment:"Adds an pattern to style languages embedded in HTML attributes.\n\nAn example of an inlined language is CSS with `style` attributes.",source_line:156,type_signature:"(syntax_styler: Syntax_Styler, attr_name: string, lang: string): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1},{name:"attr_name",type:"string",optional:!1,description:`- The name of the tag that contains the inlined language. This name will be treated as
case insensitive.`},{name:"lang",type:"string",optional:!1,description:"- The language key."}]}],dependents:["grammar_css.ts","grammar_js.ts","grammar_svelte.ts","syntax_styler_global.ts"]},{path:"grammar_svelte.ts",identifiers:[{name:"add_grammar_svelte",kind:"function",doc_comment:`Based on \`prism-svelte\` (https://github.com/pngwn/prism-svelte)
by pngwn (https://github.com/pngwn)

MIT license`,see_also:["`LICENSE`"],source_line:14,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]},{name:"grammar_svelte_add_inlined",kind:"function",source_line:159,type_signature:"(syntax_styler: Syntax_Styler, tag_name: string, lang: string): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1},{name:"tag_name",type:"string",optional:!1},{name:"lang",type:"string",optional:!1}]}],dependencies:["grammar_markup.ts"],dependents:["syntax_styler_global.ts"]},{path:"grammar_ts.ts",identifiers:[{name:"add_grammar_ts",kind:"function",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:12,type_signature:"(syntax_styler: Syntax_Styler): void",return_type:"void",parameters:[{name:"syntax_styler",type:"Syntax_Styler",optional:!1}]}],dependencies:["grammar_clike.ts"],dependents:["syntax_styler_global.ts"]},{path:"highlight_manager.ts",identifiers:[{name:"Highlight_Mode",kind:"type",source_line:4,type_signature:"Highlight_Mode"},{name:"supports_css_highlight_api",kind:"function",doc_comment:"Check for CSS Highlights API support.",source_line:9,type_signature:"(): boolean",return_type:"boolean",parameters:[]},{name:"Highlight_Manager",kind:"class",doc_comment:`Manages highlights for a single element.
Tracks ranges per element and only removes its own ranges when clearing.`,source_line:16,members:[{name:"element_ranges",kind:"variable",type_signature:"Map<string, Array<Range>>"},{name:"constructor",kind:"constructor",type_signature:"(): Highlight_Manager",parameters:[]},{name:"highlight_from_syntax_tokens",kind:"function",doc_comment:"Highlight from syntax styler token stream.",type_signature:"(element: Element, tokens: Syntax_Token_Stream): void",return_type:"void",parameters:[{name:"element",type:"Element",optional:!1},{name:"tokens",type:"Syntax_Token_Stream",optional:!1}]},{name:"clear_element_ranges",kind:"function",doc_comment:"Clear only this element's ranges from highlights.",type_signature:"(): void",return_type:"void",parameters:[]},{name:"destroy",kind:"function",type_signature:"(): void",return_type:"void",parameters:[]}]}],dependencies:["highlight_priorities.ts"],dependents:["Code_Highlight.svelte"]},{path:"highlight_priorities.gen.ts",identifiers:[{name:"gen",kind:"variable",source_line:6,type_signature:"Gen"}]},{path:"highlight_priorities.ts",identifiers:[{name:"Highlight_Token_Name",kind:"type",source_line:3,type_signature:"Highlight_Token_Name"},{name:"highlight_priorities",kind:"variable",source_line:56,type_signature:"Record<Highlight_Token_Name, number | undefined>"}],dependents:["highlight_manager.ts"]},{path:"samples/all.gen.ts",identifiers:[],dependencies:["code_sample.ts"]},{path:"samples/all.ts",identifiers:[{name:"Sample_Key",kind:"type",source_line:5,type_signature:"Sample_Key"},{name:"samples",kind:"variable",source_line:13,type_signature:"Record<Sample_Key, Code_Sample>"}],dependencies:["code_sample.ts"]},{path:"samples/sample_complex.svelte",identifiers:[{name:"sample_complex",kind:"component",props:[{name:"thing",type:"Record<string, any>",optional:!1},{name:"bound",type:"boolean",optional:!0,bindable:!0},{name:"children",type:"Snippet",optional:!1},{name:"onclick",type:"() => void",optional:!0}],source_line:1}],dependencies:["samples/Thing.svelte.ts"]},{path:"samples/sample_complex.ts",identifiers:[{name:"add",kind:"function",source_line:136,type_signature:"(x: number, y: number): number",return_type:"number",parameters:[{name:"x",type:"number",optional:!1},{name:"y",type:"number",optional:!1}]},{name:"Some_Type",kind:"type",source_line:7,type_signature:"Some_Type"},{name:"a",kind:"variable",source_line:122,type_signature:"1"},{name:"b",kind:"variable",source_line:122,type_signature:"string"},{name:"c",kind:"variable",source_line:122,type_signature:"true"},{name:"D",kind:"variable",source_line:122,type_signature:"typeof D"},{name:"Some_E",kind:"type",source_line:126,type_signature:"Some_E<T>",generic_params:[{name:"T",default_type:"null"}],properties:[{name:"name",kind:"variable",type_signature:"string"},{name:"age",kind:"variable",type_signature:"number"},{name:"t",kind:"variable",type_signature:"T"}]},{name:"some_e",kind:"variable",source_line:134,type_signature:"Map<string, Some_E<null>>"},{name:"plus",kind:"function",source_line:140,type_signature:"(a: any, b: any): any",return_type:"any",parameters:[{name:"a",type:"any",optional:!1},{name:"b",type:"any",optional:!1}]},{name:"str_with_keywords",kind:"variable",source_line:143,type_signature:'"const class function string"'},{name:"str_with_comment",kind:"variable",source_line:144,type_signature:'"// this is not a comment"'},{name:"template_with_expr",kind:"variable",source_line:145,type_signature:'"Value: 3"'},{name:"regex",kind:"variable",source_line:148,type_signature:"RegExp"},{name:"complex_regex",kind:"variable",source_line:149,type_signature:"RegExp"}],module_comment:"JSDoc comment",dependencies:["code_sample.ts"]},{path:"syntax_styler_global.ts",identifiers:[{name:"syntax_styler_global",kind:"variable",source_line:11,type_signature:"Syntax_Styler"}],dependencies:["grammar_clike.ts","grammar_css.ts","grammar_js.ts","grammar_json.ts","grammar_markdown.ts","grammar_markup.ts","grammar_svelte.ts","grammar_ts.ts","syntax_styler.ts"],dependents:["Code.svelte","Code_Highlight.svelte"]},{path:"syntax_styler.ts",identifiers:[{name:"Add_Syntax_Grammar",kind:"type",source_line:4,type_signature:"Add_Syntax_Grammar"},{name:"Syntax_Styler",kind:"class",doc_comment:`Based on Prism (https://github.com/PrismJS/prism)
by Lea Verou (https://lea.verou.me/)

MIT license`,see_also:["`LICENSE`"],source_line:14,members:[{name:"langs",kind:"variable",type_signature:"Record<string, Syntax_Grammar | undefined>"},{name:"add_lang",kind:"function",type_signature:"(id: string, grammar: Syntax_Grammar_Raw, aliases?: string[] | undefined): void",return_type:"void",parameters:[{name:"id",type:"string",optional:!1},{name:"grammar",type:"Syntax_Grammar_Raw",optional:!1},{name:"aliases",type:"string[] | undefined",optional:!0}]},{name:"add_extended_lang",kind:"function",type_signature:"(base_id: string, extension_id: string, extension: Syntax_Grammar_Raw, aliases?: string[] | undefined): Syntax_Grammar",return_type:"Syntax_Grammar",parameters:[{name:"base_id",type:"string",optional:!1},{name:"extension_id",type:"string",optional:!1},{name:"extension",type:"Syntax_Grammar_Raw",optional:!1},{name:"aliases",type:"string[] | undefined",optional:!0}]},{name:"get_lang",kind:"function",type_signature:"(id: string): Syntax_Grammar",return_type:"Syntax_Grammar",parameters:[{name:"id",type:"string",optional:!1}]},{name:"stylize",kind:"function",doc_comment:"Generates HTML with syntax highlighting from source code.\n\n**Process:**\n1. Runs `before_tokenize` hook\n2. Tokenizes code using the provided or looked-up grammar\n3. Runs `after_tokenize` hook\n4. Runs `wrap` hook on each token\n5. Converts tokens to HTML with CSS classes\n\n**Parameter Relationship:**\n- `lang` is ALWAYS required for hook context and identification\n- `grammar` is optional; when undefined, automatically looks up via `this.get_lang(lang)`\n- When both are provided, `grammar` is used for tokenization, `lang` for metadata\n\n**Use cases:**\n- Standard usage: `stylize(code, 'ts')` - uses registered TypeScript grammar\n- Custom grammar: `stylize(code, 'ts', customGrammar)` - uses custom grammar but keeps 'ts' label\n- Extended grammar: `stylize(code, 'custom', this.extend_grammar('ts', extension))` - new language variant",type_signature:"(text: string, lang: string, grammar?: Syntax_Grammar | undefined): string",return_type:"string",return_description:"HTML string with syntax highlighting using CSS classes (`.token_*`)",parameters:[{name:"text",type:"string",optional:!1,description:"- The source code to syntax highlight."},{name:"lang",type:"string",optional:!1,description:"- Language identifier (e.g., 'ts', 'css', 'html'). Used for:\n- Grammar lookup when `grammar` is undefined\n- Hook context (`lang` field passed to hooks)\n- Language identification in output"},{name:"grammar",type:"Syntax_Grammar | undefined",optional:!1,description:"- Optional custom grammar object. When undefined, automatically\nlooks up the grammar via `this.get_lang(lang)`. Provide this to use a custom\nor modified grammar instead of the registered one.",default_value:"this.get_lang(lang)"}]},{name:"grammar_insert_before",kind:"function",doc_comment:`Inserts tokens _before_ another token in a language definition or any other grammar.

## Usage

This helper method makes it easy to modify existing languages. For example, the CSS language definition
not only defines CSS styling for CSS documents, but also needs to define styling for CSS embedded
in HTML through \`<style>\` elements. To do this, it needs to modify \`syntax_styler.get_lang('markup')\` and add the
appropriate tokens. However, \`syntax_styler.get_lang('markup')\` is a regular JS object literal, so if you do
this:

\`\`\`js
syntax_styler.get_lang('markup').style = {
    // token
};
\`\`\`

then the \`style\` token will be added (and processed) at the end. \`insert_before\` allows you to insert tokens
before existing tokens. For the CSS example above, you would use it like this:

\`\`\`js
grammar_insert_before('markup', 'cdata', {
    'style': {
        // token
    }
});
\`\`\`

## Special cases

If the grammars of \`inside\` and \`insert\` have tokens with the same name, the tokens in \`inside\`'s grammar
will be ignored.

This behavior can be used to insert tokens after \`before\`:

\`\`\`js
grammar_insert_before('markup', 'comment', {
    'comment': syntax_styler.get_lang('markup').comment,
    // tokens after 'comment'
});
\`\`\`

## Limitations

The main problem \`insert_before\` has to solve is iteration order. Since ES2015, the iteration order for object
properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
differently when keys are deleted and re-inserted. So \`insert_before\` can't be implemented by temporarily
deleting properties which is necessary to insert at arbitrary positions.

To solve this problem, \`insert_before\` doesn't actually insert the given tokens into the target object.
Instead, it will create a new object and replace all references to the target object with the new one. This
can be done without temporarily deleting properties, so the iteration order is well-defined.

However, only references that can be reached from \`syntax_styler.langs\` or \`insert\` will be replaced. I.e. if
you hold the target object in a variable, then the value of the variable will not change.

\`\`\`js
var oldMarkup = syntax_styler.get_lang('markup');
var newMarkup = grammar_insert_before('markup', 'comment', { ... });

assert(oldMarkup !== syntax_styler.get_lang('markup'));
assert(newMarkup === syntax_styler.get_lang('markup'));
\`\`\``,type_signature:"(inside: string, before: string, insert: Syntax_Grammar_Raw, root?: Record<string, any>): Syntax_Grammar",return_type:"Syntax_Grammar",return_description:"the new grammar object",parameters:[{name:"inside",type:"string",optional:!1,description:"- The property of `root` (e.g. a language id in `syntax_styler.langs`) that contains the\nobject to be modified."},{name:"before",type:"string",optional:!1,description:"- The key to insert before."},{name:"insert",type:"Syntax_Grammar_Raw",optional:!1,description:"- An object containing the key-value pairs to be inserted."},{name:"root",type:"Record<string, any>",optional:!1,description:"- The object containing `inside`, i.e. the object that contains the\nobject to be modified.\n\nDefaults to `syntax_styler.langs`.",default_value:"this.langs"}]},{name:"stringify_token",kind:"function",doc_comment:"Converts the given token or token stream to an HTML representation.\n\nRuns the `wrap` hook on each `Syntax_Token`.",type_signature:"(o: string | Syntax_Token_Stream | Syntax_Token, lang: string): string",return_type:"string",return_description:"The HTML representation of the token or token stream.",parameters:[{name:"o",type:"string | Syntax_Token_Stream | Syntax_Token",optional:!1,description:"- The token or token stream to be converted."},{name:"lang",type:"string",optional:!1,description:"- The name of current language."}]},{name:"extend_grammar",kind:"function",doc_comment:`Creates a deep copy of the language with the given id and appends the given tokens.

If a token in \`extension\` also appears in the copied language, then the existing token in the copied language
will be overwritten at its original position.

## Best practices

Since the position of overwriting tokens (token in \`extension\` that overwrite tokens in the copied language)
doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
understand the language definition because, normally, the order of tokens matters in the grammars.

Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
Furthermore, all non-overwriting tokens should be placed after the overwriting ones.`,type_signature:"(base_id: string, extension: Syntax_Grammar_Raw): Syntax_Grammar",return_type:"Syntax_Grammar",return_description:"the new grammar",parameters:[{name:"base_id",type:"string",optional:!1,description:"- The id of the language to extend. This has to be a key in `syntax_styler.langs`."},{name:"extension",type:"Syntax_Grammar_Raw",optional:!1,description:"- The new tokens to append."}]},{name:"normalize_pattern",kind:"function",modifiers:["private"],doc_comment:`Normalize a single pattern to have consistent shape.
This ensures all patterns have the same object shape for V8 optimization.`,type_signature:"(pattern: RegExp | Syntax_Grammar_Token_Raw, visited: Set<number>): Syntax_Grammar_Token",return_type:"Syntax_Grammar_Token",parameters:[{name:"pattern",type:"RegExp | Syntax_Grammar_Token_Raw",optional:!1},{name:"visited",type:"Set<number>",optional:!1}]},{name:"normalize_grammar",kind:"function",modifiers:["private"],doc_comment:`Normalize a grammar to have consistent object shapes.
This performs several optimizations:
1. Merges \`rest\` property into main grammar
2. Ensures all pattern values are arrays
3. Normalizes all pattern objects to have consistent shapes
4. Adds global flag to greedy patterns

This is called once at registration time to avoid runtime overhead.`,type_signature:"(grammar: Syntax_Grammar_Raw, visited: Set<number>): void",return_type:"void",parameters:[{name:"grammar",type:"Syntax_Grammar_Raw",optional:!1},{name:"visited",type:"Set<number>",optional:!1,description:"- Set of grammar object IDs already normalized (for circular references)"}]},{name:"plugins",kind:"variable",type_signature:"Record<string, any>"},{name:"hooks_before_tokenize",kind:"variable",type_signature:"Array<Hook_Before_Tokenize_Callback>"},{name:"hooks_after_tokenize",kind:"variable",type_signature:"Array<Hook_After_Tokenize_Callback>"},{name:"hooks_wrap",kind:"variable",type_signature:"Array<Hook_Wrap_Callback>"},{name:"add_hook_before_tokenize",kind:"function",type_signature:"(cb: Hook_Before_Tokenize_Callback): void",return_type:"void",parameters:[{name:"cb",type:"Hook_Before_Tokenize_Callback",optional:!1}]},{name:"add_hook_after_tokenize",kind:"function",type_signature:"(cb: Hook_After_Tokenize_Callback): void",return_type:"void",parameters:[{name:"cb",type:"Hook_After_Tokenize_Callback",optional:!1}]},{name:"add_hook_wrap",kind:"function",type_signature:"(cb: Hook_Wrap_Callback): void",return_type:"void",parameters:[{name:"cb",type:"Hook_Wrap_Callback",optional:!1}]},{name:"run_hook_before_tokenize",kind:"function",type_signature:"(ctx: Hook_Before_Tokenize_Callback_Context): void",return_type:"void",parameters:[{name:"ctx",type:"Hook_Before_Tokenize_Callback_Context",optional:!1}]},{name:"run_hook_after_tokenize",kind:"function",type_signature:"(ctx: Hook_After_Tokenize_Callback_Context): void",return_type:"void",parameters:[{name:"ctx",type:"Hook_After_Tokenize_Callback_Context",optional:!1}]},{name:"run_hook_wrap",kind:"function",type_signature:"(ctx: Hook_Wrap_Callback_Context): void",return_type:"void",parameters:[{name:"ctx",type:"Hook_Wrap_Callback_Context",optional:!1}]}]},{name:"Syntax_Grammar_Value_Raw",kind:"type",source_line:464,type_signature:"Syntax_Grammar_Value_Raw"},{name:"Syntax_Grammar_Raw",kind:"type",source_line:469,type_signature:"Syntax_Grammar_Raw"},{name:"Syntax_Grammar_Token_Raw",kind:"type",doc_comment:`The expansion of a simple \`RegExp\` literal to support additional properties.

The \`inside\` grammar will be used to tokenize the text value of each token of this kind.

This can be used to make nested and even recursive language definitions.

Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
each another.

Note: Grammar authors can use optional properties, but they will be normalized
to required properties at registration time for optimal performance.`,source_line:486,type_signature:"Syntax_Grammar_Token_Raw",properties:[{name:"pattern",kind:"variable",type_signature:"RegExp",doc_comment:"The regular expression of the token."},{name:"lookbehind",kind:"variable",type_signature:"boolean",doc_comment:"If `true`, then the first capturing group of `pattern` will (effectively)\nbehave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token."},{name:"greedy",kind:"variable",type_signature:"boolean",doc_comment:"Whether the token is greedy."},{name:"alias",kind:"variable",type_signature:"string | Array<string>",doc_comment:"An optional alias or list of aliases."},{name:"inside",kind:"variable",type_signature:"Syntax_Grammar_Raw | null",doc_comment:"The nested grammar of this token."}]},{name:"Syntax_Grammar_Token",kind:"type",doc_comment:`Grammar token with all properties required.
This is the normalized representation used at runtime.`,source_line:516,type_signature:"Syntax_Grammar_Token",properties:[{name:"pattern",kind:"variable",type_signature:"RegExp"},{name:"lookbehind",kind:"variable",type_signature:"boolean"},{name:"greedy",kind:"variable",type_signature:"boolean"},{name:"alias",kind:"variable",type_signature:"Array<string>"},{name:"inside",kind:"variable",type_signature:"Syntax_Grammar | null"}]},{name:"Syntax_Grammar",kind:"type",doc_comment:`A grammar after normalization.
All values are arrays of normalized tokens with consistent shapes.`,source_line:528,type_signature:"Syntax_Grammar"},{name:"Hook_Before_Tokenize_Callback",kind:"type",source_line:552,type_signature:"Hook_Before_Tokenize_Callback"},{name:"Hook_After_Tokenize_Callback",kind:"type",source_line:553,type_signature:"Hook_After_Tokenize_Callback"},{name:"Hook_Wrap_Callback",kind:"type",source_line:554,type_signature:"Hook_Wrap_Callback"},{name:"Hook_Before_Tokenize_Callback_Context",kind:"type",source_line:556,type_signature:"Hook_Before_Tokenize_Callback_Context",properties:[{name:"code",kind:"variable",type_signature:"string"},{name:"grammar",kind:"variable",type_signature:"Syntax_Grammar"},{name:"lang",kind:"variable",type_signature:"string"},{name:"tokens",kind:"variable",type_signature:"undefined"}]},{name:"Hook_After_Tokenize_Callback_Context",kind:"type",source_line:562,type_signature:"Hook_After_Tokenize_Callback_Context",properties:[{name:"code",kind:"variable",type_signature:"string"},{name:"grammar",kind:"variable",type_signature:"Syntax_Grammar"},{name:"lang",kind:"variable",type_signature:"string"},{name:"tokens",kind:"variable",type_signature:"Syntax_Token_Stream"}]},{name:"Hook_Wrap_Callback_Context",kind:"type",source_line:568,type_signature:"Hook_Wrap_Callback_Context",properties:[{name:"type",kind:"variable",type_signature:"string"},{name:"content",kind:"variable",type_signature:"string"},{name:"tag",kind:"variable",type_signature:"string"},{name:"classes",kind:"variable",type_signature:"Array<string>"},{name:"attributes",kind:"variable",type_signature:"Record<string, string>"},{name:"lang",kind:"variable",type_signature:"string"}]}],dependencies:["syntax_token.ts","tokenize_syntax.ts"],dependents:["syntax_styler_global.ts"]},{path:"syntax_token.ts",identifiers:[{name:"Syntax_Token",kind:"class",source_line:1,members:[{name:"type",kind:"variable",doc_comment:"The type of the token.\n\nThis is usually the key of a pattern in a `Grammar`.",type_signature:"string"},{name:"content",kind:"variable",doc_comment:"The strings or tokens contained by this token.\n\nThis will be a token stream if the pattern matched also defined an `inside` grammar.",type_signature:"string | Syntax_Token_Stream"},{name:"alias",kind:"variable",doc_comment:`The alias(es) of the token.
Always an array, even if empty or single value.`,type_signature:"Array<string>"},{name:"length",kind:"variable",type_signature:"number"},{name:"constructor",kind:"constructor",type_signature:"(type: string, content: string | Syntax_Token_Stream, alias: string | string[] | undefined, matched_str?: string): Syntax_Token",parameters:[{name:"type",type:"string",optional:!1},{name:"content",type:"string | Syntax_Token_Stream",optional:!1},{name:"alias",type:"string | string[] | undefined",optional:!1},{name:"matched_str",type:"string",optional:!1,default_value:"''"}]}]},{name:"Syntax_Token_Stream",kind:"type",doc_comment:`A token stream is an array of strings and \`Syntax_Token\` objects.

Syntax token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
them.

1. No adjacent strings.
2. No empty strings.

   The only exception here is the token stream that only contains the empty string and nothing else.`,source_line:49,type_signature:"Syntax_Token_Stream"}],dependents:["syntax_styler.ts","tokenize_syntax.ts"]},{path:"tokenize_syntax.ts",identifiers:[{name:"tokenize_syntax",kind:"function",doc_comment:`Accepts a string of text as input and the language definitions to use,
and returns an array with the tokenized code.

When the language definition includes nested tokens, the function is called recursively on each of these tokens.

This method could be useful in other contexts as well, as a very crude parser.`,examples:[`var code = \`var foo = 0;\`;
var tokens = tokenize_syntax(code, Syntax_Styler.langs.js);
for (var token of tokens) {
    if (token instanceof Syntax_Token && token.type === 'number') {
        console.log(\`Found numeric literal: \${token.content}\`);
    }
}`],source_line:28,type_signature:"(text: string, grammar: Syntax_Grammar): Syntax_Token_Stream",return_type:"Syntax_Token_Stream",return_description:"an array of strings and tokens, a token stream",parameters:[{name:"text",type:"string",optional:!1,description:"- a string with the code to be styled"},{name:"grammar",type:"Syntax_Grammar",optional:!1,description:"- an object containing the tokens to use\n\nUsually a language definition like `syntax_styler.get_lang('markup')`."}]}],dependencies:["syntax_token.ts"],dependents:["Code_Highlight.svelte","syntax_styler.ts"]}]};export{$a as D,Wa as P,la as S,Ga as a,sa as b,qe as f,Oa as g,Ma as m,Na as p,Da as s};
