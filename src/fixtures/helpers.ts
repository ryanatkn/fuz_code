import {readFileSync} from 'node:fs';
import {search_fs} from '@ryanatkn/gro/search_fs.js';
import {basename, join, relative} from 'node:path';
import {domstyler_global} from '$lib/domstyler_global.js';
import {boundary_scanner_global} from '$lib/boundary_scanner_global.js';
import {generate_html_from_tokens} from '$lib/boundary_scanner_html_generator.js';

export interface Sample_Spec {
	lang: string;
	variant: string;
	content: string;
	filepath: string;
}

export interface Generated_Output {
	sample: Sample_Spec;
	boundaries: Array<any>;
	domstyler_html: string;
	boundary_scanner_html: string;
}

/**
 * Discover all sample files in src/lib/samples
 */
export const discover_samples = (): Array<Sample_Spec> => {
	const sample_files = search_fs('src/lib/samples', {
		file_filter: (path) => /sample_[^/]+\.(ts|css|html|json|svelte)$/.test(path),
	});

	const samples: Array<Sample_Spec> = [];

	for (const file of sample_files) {
		const filename = basename(file.id);
		const match = filename.match(/sample_([^.]+)\.(.+)$/);
		if (!match) continue;

		const [, variant, lang] = match;
		const content = readFileSync(file.id, 'utf-8');

		samples.push({
			lang,
			variant,
			content,
			filepath: relative(process.cwd(), file.id),
		});
	}

	return samples;
};

/**
 * Get the fixture path for a given language and variant
 */
export const get_fixture_path = (lang: string, variant: string, ext: 'json' | 'md'): string => {
	return join('fixtures/generated', lang, `${lang}_${variant}.${ext}`);
};

/**
 * Generate domstyler HTML output for a sample
 */
export const generate_domstyler_output = (sample: Sample_Spec): string => {
	return domstyler_global.stylize(sample.content, sample.lang);
};

/**
 * Generate boundary detection data from boundary scanner
 */
export const generate_boundary_data = (
	sample: Sample_Spec,
): {
	boundaries: Array<any>;
} => {
	// For now, return minimal data structure
	// TODO: Extract boundary and match info from boundary scanner if needed
	return {
		boundaries: [
			{
				language: sample.lang,
				type: 'code',
				start: 0,
				end: sample.content.length,
			},
		],
	};
};

/**
 * Generate boundary scanner HTML output for a sample
 */
export const generate_boundary_scanner_output = (sample: Sample_Spec): string => {
	try {
		// Scan and get tokens
		const tokens = boundary_scanner_global.scan(sample.content, sample.lang);

		// Generate HTML from tokens
		return generate_html_from_tokens(sample.content, tokens);
	} catch (error) {
		console.error(`Boundary scanner error for ${sample.lang}_${sample.variant}:`, error);
		throw error;
	}
};

/**
 * Process a sample and generate all outputs
 */
export const process_sample = (sample: Sample_Spec): Generated_Output => {
	const domstyler_html = generate_domstyler_output(sample);
	const boundary_data = generate_boundary_data(sample);
	const boundary_scanner_html = generate_boundary_scanner_output(sample);

	return {
		sample: {
			lang: sample.lang,
			variant: sample.variant,
			content: sample.content,
			filepath: sample.filepath,
		},
		boundaries: boundary_data.boundaries,
		domstyler_html,
		boundary_scanner_html,
	};
};

/**
 * Generate markdown report for a sample
 */
export const generate_report = (output: Generated_Output): string => {
	const {sample, boundaries, domstyler_html, boundary_scanner_html} = output;

	return `# ${sample.lang.toUpperCase()} ${sample.variant.charAt(0).toUpperCase() + sample.variant.slice(1)} Sample Report

## Sample Info
- **Language**: ${sample.lang}
- **Variant**: ${sample.variant}
- **Source**: ${sample.filepath}
- **Size**: ${sample.content.length} characters

## Statistics

### Boundaries
- **Total**: ${boundaries.length}
${boundaries.map((b) => `- ${b.type}: [${b.start}:${b.end}]`).join('\n')}

## Domstyler Output
\`\`\`html
${domstyler_html}
\`\`\`

${
	boundary_scanner_html
		? `## Boundary Scanner Output
\`\`\`html
${boundary_scanner_html}
\`\`\`

`
		: ''
}
## Comparison
- Domstyler size: ${domstyler_html.length} bytes
- Boundary Scanner size: ${boundary_scanner_html.length} bytes

---
*Generated by src/fixtures/update.task.ts*
`;
};
